[[sensing-core]]
== The SensorThings API Core Data Model

All data model requirements classes are grouped in the following requirements class:


[requirements_class]
.Sensing Entities
====
[%metadata]
identifier:: {identifier}/req-class/datamodel/sensing
obligation:: requirement
subject:: Target Type: Data Model
requirement:: {identifier}/req/datamodel/sensing/thing
requirement:: {identifier}/req/datamodel/sensing/location
requirement:: {identifier}/req/datamodel/sensing/historical-location
requirement:: {identifier}/req/datamodel/sensing/datastream
requirement:: {identifier}/req/datamodel/sensing/sensor
requirement:: {identifier}/req/datamodel/sensing/observed-property
requirement:: {identifier}/req/datamodel/sensing/observation
requirement:: {identifier}/req/datamodel/sensing/feature  
====

The OGC SensorThings API v2.0 depicts the Core Sensing entities in <<img-sta-core>>

[#img-sta-core,link=figures/Datamodel-SensorThingsApi-V2-Core.drawio.png, reftext='{figure-caption} {counter:figure-num}', title='Sensing Core']
image::figures/Datamodel-SensorThingsApi-V2-Core.drawio.png[Sensing Core, align="center"]




In this section, we define each entity depicted in <<img-sta-core>> and its relationships with other entities.
Additionally, we also provide examples to model the entities in different contexts.


=== Recurring attributes

Several attributes are used in several classes.
They always have the same semantic meaning, regarless of the class they are used in.

`id`:: The primary key of the class.
  An Entity is uniquely identified, among Entities of the same class and in the same service, by its `id` value.
  The data type of the `id` attribute may vary between services, or even between classes in the same service, but must be the same for all Entities of the same class in the same service.
  In most cases the value of the `id` attribute of an Entity will be generated by the service when the Entity is created, but a service may allow users to specify a value.

`name`:: The name of an Entity is a (short) character string that describes the Entity.
  It does not need to be unique among entities of the same type, though, when two entities of the same type have the same name, there should be another distinguishing attribute.
  Two Things with the same name are likely to cause confusion, but two Datastreams with the same name are generally acceptable, as long as these Datastreams are associated to different Things.

`description`:: The description of an Entity is a longer, human readable, character string giving a descriptive text of the Entity.

`definition`:: The definition of an Entity is a unique external identifier, linking the Entity to an external, autorative source.
  The definition allows for different services to represent different aspects of the same systems.
  It can, for instance, be a URL to a feature in an OGC API - Features service, or a DID pointing to a crytographically signed resource.

`properties`:: A set of user-defined named values.
  The values may be of any type, including nested arrays or name-value sets.
  In the default JSON encoding the `properties` attribute is a JSON-Object.



[[thing]]
=== Thing

[requirement]
.Class Thing
====
[%metadata]
identifier:: {identifier}/req/datamodel/sensing/thing

Each Thing entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<thing-attributes>>.

Each Thing entity SHALL have the direct relation between a Thing entity and other entity types listed in <<thing-relations>>.
====


The SensorThings API follows the ITU-T definition, i.e., with regard to the Internet of Things, a thing is an object of the physical world (physical things) or the information world (virtual things) that is capable of being identified and integrated into communication networks [ITU-T Y.2060].
A Thing is related to the Platform entity as described in Section 4.9.2.1 of [OGC 16-079] in a way that any entity that can be modelled as a Thing MAY be subsequently translated to a Platform and vice versa.

[example%unnumbered]
====
*Thing Examples*

- A weather station that houses a varying set of environmental sensors
- A drone that mounts a LiDAR sensor for mapping purposes
- A science vessel that has many sensors installed
- An upstream oil well that is equipped with compound gas detection devices
====


[#thing-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of a Thing entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Definition*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `name`
| A property provides a label for Thing entity, commonly a descriptive name.
| String
| 1

| `definition`
| The URI linking the Thing to an external definition.
Dereferencing this URI SHOULD result in a representation of the definition of the Thing.
| URI
| 0..1

| `description`
| This is a short description of the corresponding Thing entity.
| String
| 0..1

| `properties`
| A JSON Object containing user-annotated properties.
| JSON_Object
| 0..1
|====


[#thing-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between a Thing entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*

| `Location`
| The Location entity locates the Thing.
Multiple Things MAY be located at the same Location.
A Thing MAY not have a Location.

A Thing SHOULD have only one physical location, but this location may be described in different ways, using different representations.
In such case, the Thing MAY have more than one Locations.
| `Location`
| 0..1

| `HistoricalLocations`
| A Thing has zero-to-many HistoricalLocations.
A HistoricalLocation has one-and-only-one Thing.
| `HistoricalLocation`
| 0..*

| `Datastreams`
| A Thing MAY have zero-to-many Datastreams.
| `Datastream`
| 0..*
|====

.Example of a Thing entity returned by a HTTP end point.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#Things/$entity",
  "@id": "Things(1)",
  "id": 1,
  "name": "Oven",
  "description": "This thing is an oven.",
  "properties": {
    "owner": "Ulrike Schmidt",
    "color": "Black"
  },
  "Locations@navigationLink": "Things(1)/Locations",
  "Datastreams@navigationLink": "Things(1)/Datastreams",
  "HistoricalLocations@navigationLink": "Things(1)/HistoricalLocations"
}
----





[[location]]
=== Location

[requirement]
.Class Location
====
[%metadata]
identifier:: {identifier}/req/datamodel/sensing/location

Each Location entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<location-attributes>>.

Each Location entity SHALL have the direct relation between a Location entity and other entity types listed in <<location-relations>>.
====


The Location entity geo-locates the Thing or the Things it associated with.
A Thing's Location entity is defined as the last known location of the Thing.

The Feature can be either a proximate feature of interest or the ultimate feature of interest depending upon the context of the Observation.
For __in-situ__ sensing applications, the Location MAY describe the coordinates of where the Thing is located.
The Feature is the entity for which the value of a property was determined by the Sensor.
The ObservedProperty in this case MAY characterize only the area around the sensing device or it MAY characterize the larger observedArea that the sensing application intends to capture.
Thus, depending upon the feature-of-interest, the Feature can then be either a ProximateFeatureOfInterest or UltimateFeatureOfInterest.
For __ex-situ__ sensing applications, the Location MAY describe the coordinates of where the Thing is located, whereas the feature MAY be the point location of the observed Feature.

EDITOR: Explain all 4 possible options? in-situ, local; in-site, remote; ex-situ, local; ex-situ, remote

Section 7.1.4 of [OGC 20-082r4 and ISO 19156:2023] provides a detailed explanation of observation location.

[example%unnumbered]
====
*Location Examples*

- An air quality sensing facility's Location can be the physical location where the facility is situated, but the (proximate) Feature that is characterized by the Observation could be the air envelope around the Sensor which is subsequently used to estimate the air quality of the district where the facility is situated.
- A drone that mounts a LiDAR Sensor may have its Location as the geo-referenced area over which the drone is scheduled to fly, whereas the Feature could be the individual objects mapped by the Sensor within that geo-referenced area
====



[#location-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of a Location entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Definition*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `name`
| A property provides a label for Location entity, commonly a descriptive name.
| String
| 1

| `encodingType`
| The encoding type of the Location property.
(see <<location-encodingType-value-codes>> for some suggested ValueCodes)
| String
| 1

| `location`
| The identifiable location of the Thing
| ANY
| 1

| `description`
| The description about the Location
| String
| 0..1

| `properties`
| A JSON Object containing user-annotated properties.
| JSON_Object
| 0..1
|====



[#location-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between a Location entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*

| `Things`
| The Things located at the source Location.
Multiple Things MAY locate at the same Location.
| `Thing`
| 0..*

| `HistoricalLocations`
| The HistoricalLocations of things that have been located at this Location.
| `HistoricalLocation`
| 0..*
|====


[#location-encodingType-value-codes,reftext='{table-caption} {counter:table-num}']
.Non-exhaustive list of code values used for identifying types for the encodingType of the Location and Feature entities
[width="100%",cols="5,15",options="header"]
|====
| encodingType
| ValueCode Value

| `GeoJSON`
| `application/geo+json`

| `GeoPose`
| `application/geopose+json`

| `WKT`
| `text/plain`
|====


EDITOR: Add example for wkt, jsonFG

.Example of a Location entity using a GeoJSON Feature.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#Locations/$entity",
  "@id": "Locations(1)",
  "id": 1,
  "name": "CCIT",
  "description": "Calgary Center for Innvative Technologies",
  "encodingType": "application/geo+json",
  "location": {
    "type": "Feature",
    "geometry":{
      "type": "Point",
      "coordinates": [-114.06,51.05]
    }
  },
  "Things@navigationLink": "Locations(1)/Things",
  "HistoricalLocations@navigationLink": "Locations(1)/HistoricalLocations",
}
----

.Example of a Location entity using a GeoJSON Geometry.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#Locations/$entity",
  "@id": "Locations(2)",
  "id": 2,
  "name": "IOSB",
  "description": "Fraunhofer-Institut für Optronik, Systemtechnik und Bildauswertung IOSB",
  "encodingType": "application/geo+json",
  "location": {
    "type": "Point",
    "coordinates": [8.426, 49.015]
  },
  "Things@navigationLink": "Locations(2)/Things",
  "HistoricalLocations@navigationLink": "Locations(2)/HistoricalLocations",
}
----

NOTE: When using a GeoJSON encoding for the location attribute, the value can either be a GeoJSON Feature or a GeoJSON Geometry.



[[historicallocation]]
=== HistoricalLocation

[requirement]
.Class HistoricalLocation
====
[%metadata]
identifier:: {identifier}/req/datamodel/sensing/historical-location

Each HistoricalLocation entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<historical-location-attributes>>.

Each HistoricalLocation entity SHALL have the direct relation between a HistoricalLocation entity and other entity types listed in <<historical-location-relations>>.

When a Thing has a new Location, a new HistoricalLocation SHALL be created and added to the Thing automatically by the service.
The current Location of the Thing SHALL only be added to this autogenerated HistoricalLocation automatically by the service, and SHALL not be created as HistoricalLocation directly by user.

When a user directly adds new HistoricalLocation, and the time of this new HistoricalLocation is later than the latest HistoricalLocation for the Thing, then the Locations of the Thing are changed to the Locations of this new HistoricalLocation.
====



A Thing's HistoricalLocation entity set provides the times of the current (i.e., last known) and previous locations of the Thing.
It can be used to model the path observed by a moving Thing.

[example%unnumbered]
====
*HistoricalLocation Examples*

- A drone that measures methane leaks over a large basin may want to record the trajectory through which it flies.
HistoricalLocation should then record the individual Locations of the drone over time 

====


The HistoricalLocation can also be created, updated and deleted.
One use case is to migrate historical observation data from an existing observation data management system to a SensorThings API system.
Another use case is to track the Location of a Thing, when a permanent network connection is not available.
If the Location of a Thing is changed at a later time, when a network connection is available again, then the auto-generated Time of the HistoricalLocation entity would not reflect the time when the Thing was actually at the set Location, but only the time at which the change was sent to the server.
To resolve this, the Location of a Thing can also be changed by adding a HistoricalLocation.
If the time of a manually created HistoricalLocation is later than the time of all existing HistoricalLocations, then the Location of the Thing is updated to the Location of this manually created HistoricalLocation.


[#historical-location-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of a HistoricalLocation entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Definition*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `time`
| The time when the Thing is known at the Location.
| TM_Instant
| 1
|====


[#historical-location-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between a HistoricalLocation entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*

| Locations
| The Locations for this HistoricalLocation.
One HistoricalLocation SHALL have at least one Location.
| `Location`
| 1..*

| Thing
| The Thing this HistoricalLocation positions in time.
A HistoricalLocation has exactly one Thing.
| `Thing`
| 1
|====


.Example of a HistoricalLocation entity returned by a HTTP end point.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#HistoricalLocations/$entity",
  "@id": "HistoricalLocations(1)",
  "id": 1,
  "time": "2020-03-20T16:35:23.383586Z",
  "Thing@navigationLink": "HistoricalLocations(1)/Thing",
  "Locations@navigationLink": "HistoricalLocations(1)/Locations"
}
----





[[datastream]]
=== Datastream

[requirement]
.Class Datastream
====
[%metadata]
identifier:: {identifier}/req/datamodel/sensing/datastream

Each Datastream entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<datastream-attributes>>.

Each Datastream entity SHALL have the direct relation between a Datastream entity and other entity types listed in <<datastream-relations>>.
====


A Datastream groups a collection of Observations into a time series measuring the same ObservedProperty by the same Sensor for the same Feature for the same Thing.
Examples of Datastreams could be:

- An air quality monitoring station may have multiple Datastreams, each recording a specific pollutant measured by a specific sensor.
- A sensor that measures multiple ObservedProperties can generate a single Datastream with a composite resultType.



[#datastream-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of a Datastream entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Definition*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `name`
| A property provides a label for Datastream entity, commonly a descriptive name.
| String
| 1

| `description`
| The description of the Datastream entity.
| String
| 0..1

| `resultType`
| The formal description of the `result` field of the Observations in this Datastream.
Contains the unit of measurement and the `definition` of the ObservedProperty.
| JSON_Object (SWE-Common AbstractDataComponent)
| 1

| `observedArea`
| The spatial bounding box of the spatial extent of the Feature that belong to the Observations associated with this Datastream.
This is usually generated by the server.
| Geometry
| 0..1

| `phenomenonTime`
| The temporal interval of the phenomenon times of all observations belonging to this Datastream.
This is usually generated by the server.
| TM_Period
| 0..1

| `resultTime`
| The temporal interval of the result times of all observations belonging to this Datastream.
This is usually generated by the server.
| TM_Period
| 0..1

| `properties`
| A JSON Object containing user-annotated properties.
| JSON_Object
| 0..1
|====

TM_Period is by default encoded as a complex type with a start (mandatory) and end (mandatory) attributes of type TM_Instant.


[#datastream-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between a Datastream entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*

| `Thing`
| The Thing this Datastream holds Observations for.
| `Thing`
| 1

| `Sensor`
| The Sensor that made the Observations in this Datastream.
| `Sensor`
| 1

| `ObservedProperty`
| The ObservedProperty of the Observations in this Datastream.
The Observations in a Datastream may hold values for multiple ObservedProperties, but the ObservedProperties are the same for all Observations in the same Datastream.
The service must ensure the definitions of the linked ObservedProperties match the definitions used in the `resultType`.
| `ObservedProperty`
| 1..*

| `Observations`
| The Observations for a Datastream.
| `Observation`
| 0..*

| `UltimateFeatureOfInterest`
| The Feature has the role UltimateFeatureOfInterest so that all the Observations in a Datastream pertain only to the same linked Feature
| `Feature`
| 0..1
|====


The resultType defines the result types for specialized single and multi observations based on the JSON encoding of the SWE Common Data Model [OGC 08-094r1 and OGC 17-011r2].
The result of an Observation may be a single simple number or String, or it may contain a complex JSON structure holding multiple values for multiple ObservedProperties.
The exact definition for this result structure, and which unit of measurement and which ObservedProperty pertains to each value in the result structure is exactly described by this resultType Object.

EDITOR: Update to new SWE-Common!

In most cases each Observation holds a single numeric result value, measured by a single Sensor.
In this case the resultType is of the SWE-Common class `Quantity` (though a number could also be a `Count`) and thus must have the fields `type`, `definition`, `label`, and `uom`.

- The `type` field defines the type of the result and has the value `Quantity`.
- The `definition` must be the same as the `definition` field in the single ObservedProperty linked to the Datastream.
- The `uom` field contains the unit of measurement, and is an object that must contain either a `code` field with the UCUM code of the unit, or a `href` field with a URI pointing to a unit definition. It may also contain the `label` and `symbol` fields that can be displayed in user interfaces.
- The `label` field is somewhat redundant in this case, but since it is mandatory it can be set to the same value as the Datastream `name`.


.A Datastream example measuring a scalar Observation
[source,json]
----
{
  "name": "Oven temperature",
  "description": "This is a datastream measuring the air temperature in an oven.",
  "resultType": {
    "type": "Quantity",
    "label": "Oven temperature",
    "definition": "http://mmisw.org/ont/cf/parameter/air_temperature",
    "uom": { "code": "Cel", "label": "degree Celsius", "symbol": "°C" }
  }
}
----

.An Observation for the Datastream defined in the example above
[source,json]
----
{
  "result": 25.1,
  "phenomenonTime":  {
    "start": "2021-13-14T15:16:00Z"
  }
}
----


Another common type of result is a value from a key list.
An example would be an Observation of the current weather as `Fair` or `Overcast`, or the geological dating of a rock sample to be `Jurassic`.
In the latter case, the code space that defines the values could be the Sweet ontology.
In this example the resultType is a `Category` and thus must have the fields `type`, `definition`, `label`, and `codeSpace`.

- The `type` field defines the type of the result and has the value `Category`.
- The `definition` must be the same as the `definition` field in the single ObservedProperty linked to the Datastream.
- The `codeSpace` field must be a reference that defines the valid values that can be used as results.
- The `label` field is somewhat redundant in this case, but since it is mandatory it can be set to the same value as the Datastream `name`.


.A Datastream example for Observations with category values from a predefined code space
[source,json]
----
{
  "name": "Sample Dating",
  "description": "This is a datastream containing the geological datings of rock samples.",
  "resultType": {
    "type": "Category",
    "label": "Sample Dating",
    "definition": "http://sweetontology.net/stateTime/Period",
    "codeSpace": "http://sweetontology.net/stateTimeGeologic/"
  }
}
----

.An Observation for a Datastream defined in the example above
[source,json]
----
{
  "result": "Jurassic",
  "phenomenonTime":  {
    "start": "2021-13-14T15:16:00Z"
  }
}
----


In some cases, a (composite) Sensor generates multiple values that should be kept together.
This can be achieved with a `DataRecord` resultType.
In the below example, a temperature and pressure value are stored as a pair, per Observation.
The resultType has the SWE-Common class `DataRecord`, which is a composite class that contains sub-entries.
The mandatory fields of a DataRecord are `type` and `fields`:

- The `type` field defines the type of the result and has the value `DataRecord`.
- The `fields` field is an array of other SWE-Common components.
  In this example there are two `Quantity` entries.
  Each entry has the mandatory fields for a `Quantity`.

Since there are two _distinct_ `definition` fields in the resultType, this Datastream must be linked to two ObservedProperties that match the two definitions.

.A Datastream example measuring multiple observedProperties
[source,json]
----
{
  "name": "Temperature and Pressure",
  "description": "This is a datastream containing temperature and pressure measurement sets.",
  "resultType": {
    "type": "DataRecord",
    "fields": [
      {
        "name": "temp",
        "type": "Quantity",
        "label": "Air Temperature",
        "definition": "http://mmisw.org/ont/cf/parameter/air_temperature",
        "uom": { "code": "Cel", "label": "degree Celsius", "symbol": "°C"  }
      },
      {
        "name": "press",
        "type": "Quantity",
        "label": "Air Pressure",
        "definition": "http://mmisw.org/ont/cf/parameter/air_pressure_at_mean_sea_level",
        "uom": { "code": "mbar", "label": "Millibar", "symbol": "mBar"  }
      }
    ]
  }
}
----

.An Observation for a Datastream defined in the example above
[source,json]
----
{
  "result": {
    "temp": 15,
    "press": 1024
  },
  "phenomenonTime": {
    "start": "2021-13-14T15:16:00Z"
  }
}
----



[[sensor]]
=== Sensor

[requirement]
.Class Sensor
====
[%metadata]
identifier:: {identifier}/req/datamodel/sensing/sensor

Each Sensor entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<sensor-attributes>>.

Each Sensor entity SHALL have the direct relation between a Sensor entity and other entity types listed in <<sensor-relations>>.
====

A Sensor is an entity that observes a property or phenomenon with the goal of producing an estimate of the value of the property.
A Sensor may represent a piece of hardware, but a Sensor may also be a human or an algorithm implemented in sofware.


[#sensor-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of a Sensor entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Definition*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `name`
| A property provides a label for Sensor entity, commonly a descriptive name.
| String
| 1
| `description`
| The description of the Sensor entity.
| String
| 0..1

| `encodingType`
| The encoding type of the metadata property.
Its value is one of the ValueCode enumeration (see <<sensor-encodingType-value-codes>> for some suggested ValueCodes)
| ValueCode
| 1

| `metadata`
| The detailed description of the Sensor or system.
The metadata type is defined by encodingType.
| String
| 1

| `properties`
| A JSON Object containing user-annotated properties as key-value pairs
| JSON_Object
| 0..1
|====


[#sensor-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between a Sensor entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*

| `Datastreams`
| The Datastreams that hold Observations produced by this Sensor.
| `Datastream`
| 0..*
|====


[#sensor-encodingType-value-codes,reftext='{table-caption} {counter:table-num}']
.Non-exhaustive list of code values used for identifying types for the encodingType of the Sensor entity
[width="100%",cols="5,15",options="header"]
|====
| Sensor encodingType
| ValueCode Value

| `PDF`
| application/pdf

| `SensorML`
| http://www.opengis.net/doc/IS/SensorML/2.0

| `HTML`
| text/html
|====


The Sensor encodingType allows clients to know how to interpret the metadata value.
Currently SensorThings API defines two common Sensor metadata encodingTypes.
Most sensor manufacturers provide their sensor datasheets in a PDF format.
As a result, PDF is a Sensor encodingType supported by SensorThings API.
The second Sensor encodingType is SensorML.
Lastly, some sensor datasheets are HTML documents rather than PDFs.
Other encodingTypes are permitted (e.g., text/plain).
Note that the metadata property may contain either a URL to metadata content (e.g., an `https://`, `ftp://`, etc. link to a PDF, SensorML, or HTML document) or the metadata content itself (in the case of text/plain or other encodingTypes that can be represented as valid JSON).
It is up to clients to perform string parsing necessary to properly handle metadata content.


.Example of a Sensor entity returned by a HTTP end point.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#Sensors/$entity",
  "@id": "Sensors(1)",
  "id": 1,
  "name": "TMP36",
  "description": "TMP36 - Analog Temperature sensor",
  "encodingType": "application/pdf",
  "metadata": "http://example.org/TMP35_36_37.pdf",
  "Datastreams@navigationLink": "Sensors(1)/Datastreams"
}
----




[[observedproperty]]
=== ObservedProperty

[requirement]
.Class ObservedProperty
====
[%metadata]
identifier:: {identifier}/req/datamodel/sensing/observed-property

Each ObservedProperty entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<observed-property-attributes>>.

Each ObservedProperty entity SHALL have the direct relation between an ObservedProperty entity and other entity types listed in <<observed-property-relations>>.
====

An ObservedProperty is a property of a Feature that is being observed by a Sensor, such as temperature, humidity, population count or colour.
It should be uniquely identified by its `definition`, which should point to an external vocabulary by means of a URL, URI or DID.


[#observed-property-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of an ObservedProperty entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Definition*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `name`
| A property provides a label for ObservedProperty  entity, commonly a descriptive name.
| String
| 1

| `definition`
| The URI of the ObservedProperty.
Dereferencing this URI SHOULD result in a representation of the definition of the ObservedProperty
| URI
| 1

| `description`
| A description about the ObservedProperty.
| String
| 0..1

| `properties`
| A JSON Object containing user-annotated properties as key-value pairs
| JSON_Object
| 0..1
|====


[#observed-property-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between an ObservedProperty entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*

| `Datastreams`
| Datastreams that hold Observations that observed this ObservedProperty.
| `Datastream`
| 0..*
|====


.Example of an ObservedProperty entity returned by a HTTP end point.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#ObservedProperties/$entity",
  "@id": "ObservedProperties(1)",
  "id": 1,
  "name": "DewPoint Temperature",
  "description": "The dewpoint temperature is the temperature to which the
                  air must be cooled, at constant pressure, for dew to form.
                  As the grass and other objects near the ground cool to
                  the dewpoint, some of the water vapor in the atmosphere
                  condenses into liquid water on the objects.",
  "definition": "http://dbpedia.org/page/Dew_point",
  "Datastreams@navigationLink": "ObservedProperties(1)/Datastreams"
}
----





[[observation]]
=== Observation

[requirement]
.Class Observation
====
[%metadata]
identifier:: {identifier}/req/datamodel/sensing/observation

Each Observation entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<observation-attributes>>.

Each Observation entity SHALL have the direct relation between an Observation entity and other entity types listed in <<observation-relations>>.
====


An Observation provides a value for an ObservedProperty of a Feature, as observed by a Sensor.
This value can be of any type, as described by the resultType of the Datastream that Observation is associated with.


[#observation-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of an Observation entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Definition*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `phenomenonTime`
| The time instant or period of when the Observation happens.

Note: Many resource-constrained sensing devices do not have a clock.
As a result, a client may omit phenomenonTime when POST new Observations, even though phenomenonTime is a mandatory property.
When a SensorThings service receives a POST Observations without phenomenonTime, the service SHALL assign the current server time to the value of the phenomenonTime
| TM_Object
| 1

| `result`
| The estimated value of an ObservedProperty from the Observation.
| ANY
| 1
| `resultTime`
| The time of the Observation's result was generated
| TM_Instant
| 0..1

| `validTime`
| The time period during which the result may be used
| TM_Period
| 0..1

| `properties`
| A JSON Object containing user-annotated properties as key-value pairs (usually showing the environmental conditions during measurement)
| JSON_Object
| 0..1
|====

TM_Object is by default encoded as a complex type with a start (mandatory) and end (optional) attributes of type TM_Instant.
This means it can either describe a time instant, when only the start is present, or a time interval with both stand and end are present.

TM_Period is by default encoded as a complex type with a start (mandatory) and end (mandatory) attributes of type TM_Instant.
This means it always describes a time interval with fixed starting and ending instants.



[#observation-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between an Observation entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*

| `Datastream`
| The Datastream this Observation exists in.
| `Datastream`
| 1

| `ProximateFeatureOfInterest`
| The Feature observed by the Observation.
| `Feature`
| 0..1
|====

An Observation can be directly linked to a Feature, through the relation `ProximateFeatureOfInterest`. Features linked to an Observation in this way are generally samples, either real, physical ones, like water samples taken from a river, or transient ones, to fix the place that a moving Thing happended to be in, when it made a measurement.

In case the Feature is a domain object, like a river, a building, or a plot of land, the Feature is indirectly linked to the Observation through the `UltimateFeatureOfInterest` relation on the Datastream. It is also possible for both relations to exist, in which case the `ProximateFeatureOfInterest` is a sample of the `UltimateFeatureOfInterest`.

A third case is possible, when the target of the observation is (a sub-part of) the Thing itself. For instance, when the Observation is on the battery-level of a drone. In this case neither the `ProximateFeatureOfInterest`, nor the `UltimateFeatureOfInterest` need to be set.


.Example of an Observation entity returned by a HTTP end point.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#Observations/$entity",
  "@id": "Observations(1)",
  "id": 1,
  "phenomenonTime": {
    "start": "2017-11-12T13:00:00Z",
    "end": "2017-11-12T14:00:00Z"
  },
  "resultTime": "2017-11-12T14:00:00Z",
  "result": 12.5,
  "Datastream@navigationLink": "Observations(1)/Datastream",
  "proximateFeatureOfInterest@navigationLink": "Observations(1)/proximateFeatureOfInterest"
}
----




[[feature]]
=== Feature

[requirement]
.Class Feature
====
[%metadata]
identifier:: {identifier}/req/datamodel/sensing/feature

Each Feature entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<feature-attributes>>.

Each Feature entity SHALL have the direct relation between a Feature entity and other entity types listed in <<feature-relations>>.
====


An Observation assigns a value to a property of a subject by applying an ObservingProcedure.
The subject is the Feature that can take the role of ProximateFeatureOfInterest or ultimateFeatureOfInterest of the Observation [OGC 20-082r4 and ISO 19156:2023].
In cases where estimating the value of a property of interest is not possible directly, a proxy feature MAY be used.
Such an application typically requires Sampling the UltimateFeatureOfInterest such that the observed Feature represents an approximation of the domain feature.
In many sensing applications, the Observations’ Feature can be ambiguous with the Location of the Thing.
Thus the concept of roles is introduced to better describe the relationship between an Observation and it's Feature.

[example%unnumbered]
====
*Feature Examples*

- The Feature of a WiFi enabled thermostat can be the Location of the thermostat (i.e., the living room where the thermostat is located in).
However, in such cases, it is recommended to use the Location entity to store this information while the Feature entity (with the role of proximateFeatureOfInterest) can be used to model the ambient indoor atmosphere around the thermostat that approximates the overall room's temperature.

- In the case of remote sensing, the Feature observed can be the individual geographical parcel or swath that is being sensed, while the Location entity can maintain the larger geographical region that is being monitored.
====


[#feature-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of a Feature entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Definition*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `name`
| A property provides a label for Feature entity, commonly a descriptive name.
| String
| 1

| `description`
| The description about the Feature
| String
| 0..1

| `encodingType`
| The encoding type of the feature property. (see <<location-encodingType-value-codes>> for some suggested ValueCodes)
| String
| 1

| `feature`
| The detailed description of the feature.
The data type is defined by encodingType.
| ANY
| 0..1

| `properties`
| A JSON Object containing user-annotated properties as key-value pairs
| JSON_Object
| 0..1
|====


[#feature-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between a Feature entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*                

| `Observations`
| All Observations that are made on this Feature
| `Observation`
| 0..*

| `Datastreams`
| All Datastreams that contain Observations relevant for this Feature.
| `Datastream`
| 0..*
|====


.Example of a Feature entity using a GeoJSON Geometry.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#Features/$entity",
  "@id": "Features(1)",
  "id": 1,
  "name": "0113700020130227",
  "description": "Water Sample from LA NOYE À DOMMARTIN (80) taken on 2013-02-27 at 10:20:00",
  "encodingType": "application/geo+json",
  "feature": {
    "type": "Point",
    "coordinates": [
      2.38961955,
      49.800951554
    ]
  },
  "FeatureType@navigationLink": "FeaturesOfInterest(1)/FeatureType",
  "Datastreams@navigationLink": "FeaturesOfInterest(1)/Datastreams",
  "Observations@navigationLink": "FeaturesOfInterest(1)/Observations"
}
----

EDITOR: Add non-GeoJSON examples!





[[featuretype]]
=== FeatureType

[requirement]
.Class FeatureType
====
[%metadata]
identifier:: {identifier}/req/datamodel/sensing/feature-type

Each FeatureType entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<feature-type-attributes>>.

Each FeatureType entity SHALL have the direct relation between a FeatureType entity and other entity types listed in <<feature-type-relations>>.
====


The type or types of each Feature can be specified using the FeatureType class.
The `definition` attribute of the FeatureType should point to an external registry or code list, that defines the Type.


[#feature-type-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of a FeatureType entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Description*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `name`
| A property provides a label for Feature entity, commonly a descriptive name.
| String
| 1

| `description`
| The description about the Feature
| String
| 0..1

| `definition`
| The URI the defines this FeatureType.
Dereferencing this URI SHOULD result in a representation of the definition of the FeatureType.
| URI
| 0..1

| `properties`
| A JSON Object containing user-annotated properties as key-value pairs
| JSON_Object
| 0..1
|====


[#feature-type-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between a FeatureType entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*                

| `Features`
| All Features of a FeatureType.
| `Feature`
| 0..*
|====


.Example of a FeatureType entity.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#FeatureType/$entity",
  "@id": "FeatureType(1)",
  "id": 1,
  "name": "Water Sample",
  "description": "A Sample taken from a river, lake or sea",
  "definition": "https://example.org/water_sample",
  "Features@navigationLink": "FeatureType(1)/Features"
}
----




