[[sensing-core]]
== The SensorThings API Core Data Model

=== Introduction

The core data model is designed based on the OGC/ISO Observation, Measurements and Samples (OMS) model (<<OgcOMS>> and <<IsoOMS>>).
An Observation is modeled as an act that produces a result whose value is an estimate of a property of a given Feature.
An Observation instance is characterized by its event time (e.g., resultTime and phenonmenonTime), Feature, ObservedProperty, and the observer that made the Observation (often a Sensor).

The SensorThings API also models Things.
A Thing draws from the same concept as a Host in OMS where a Host is defined as a collection of Observers (defined as Sensor in SensorThings API).
Formally, its definition follows the ITU-T definition:
“__an object of the physical world (physical things) or the information world (virtual things) that is capable of being identified and integrated into communication networks__” <<ITU-T-Y.2060>>.

The geographical Locations of Things are useful in almost every application and as a result are included as well.
For the Things whose location changed, the HistoricalLocations entities offer the history of the Thing's locations.

A Thing also can have multiple Datastreams.
A Datastream is a collection of Observations grouped by the same ObservedProperty, Sensor and optionally by Feature and ObservingProcedure.

An Observation is an event performed by a Sensor that produces a result whose value is an estimate of an ObservedProperty of any given Feature which may be a proximate or ultimate FeatureofInterest.
Details of each above described entity are provided in the sections below.

All data model requirements are grouped in the following requirements class:


[requirements_class]
.Core Data Model
====
[%metadata]
identifier:: {identifier}/req-class/datamodel/core
obligation:: requirement
subject:: Data Model
requirement:: {identifier}/req/datamodel/core/thing
requirement:: {identifier}/req/datamodel/core/location
requirement:: {identifier}/req/datamodel/core/historical-location
requirement:: {identifier}/req/datamodel/core/datastream
requirement:: {identifier}/req/datamodel/core/sensor
requirement:: {identifier}/req/datamodel/core/observed-property
requirement:: {identifier}/req/datamodel/core/observation
requirement:: {identifier}/req/datamodel/core/feature
requirement:: {identifier}/req/datamodel/core/feature-type
requirement:: {identifier}/req/datamodel/core/integrity
====

The OGC SensorThings API v2.0 Core data model is depicted in <<img-sta-core>>

[#img-sta-core,link=figures/Datamodel-SensorThingsApi-V2-Core.drawio.png, reftext='{figure-caption} {counter:figure-num}', title='UML class diagram of the SensorThings API Core data model']
image::figures/Datamodel-SensorThingsApi-V2-Core.drawio.png[Sensing Core, align="center"]



In this section, we define each entity depicted in <<img-sta-core>> and its relationships with other entities.
Additionally, we also provide examples to model the entities in different contexts.


=== Recurring attributes

Several attributes are used in several classes.
They always have the same semantic meaning, regarless of the class they are used in.

`id`:: The primary key of the class.
  An Entity is uniquely identified, among Entities of the same class and in the same service, by its `id` value.
  The data type of the `id` attribute may vary between services, or even between classes in the same service, but must be the same for all Entities of the same class in the same service.
  In most cases the value of the `id` attribute of an Entity will be generated by the service when the Entity is created, but a service may allow users to specify a value.

`name`:: The name of an Entity is a (short) character string that describes the Entity.
  It does not need to be unique among entities of the same type, though, when two entities of the same type have the same name, there should be another distinguishing attribute.
  Two Things with the same name are likely to cause confusion, but two Datastreams with the same name are generally acceptable, as long as these Datastreams are associated to different Things.

`description`:: The description of an Entity is a longer, human readable, character string giving a descriptive text of the Entity.

`definition`:: The definition of an Entity is a unique external identifier, linking the Entity to an external, autorative source.
  The definition allows for different services to represent different aspects of the same systems.
  It can, for instance, be a URL to a feature in an OGC API - Features service, or a DID pointing to a crytographically signed resource.

`properties`:: A set of user-defined named values.
  The values may be of any type, including nested arrays or name-value sets.
  In the default JSON encoding the `properties` attribute is a JSON-Object.



[[thing]]
=== Thing

[requirement]
.Class Thing
====
[%metadata]
identifier:: {identifier}/req/datamodel/core/thing

part:: Each Thing entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<thing-attributes>>.

part:: Each Thing entity SHALL have the direct relation between a Thing entity and other entity types listed in <<thing-relations>>.
====


The SensorThings API follows the ITU-T definition, i.e., with regard to the Internet of Things, a thing is an object of the physical world (physical things) or the information world (virtual things) that is capable of being identified and integrated into communication networks [ITU-T Y.2060].
A Thing is related to the Platform entity as described in Section 4.9.2.1 of [OGC 16-079] in a way that any entity that can be modelled as a Thing MAY be subsequently translated to a Platform and vice versa.

Examples of the use of Thing are:

- A weather station that houses a varying set of environmental sensors
- A thermostat in a room, monitoring and controlling the temperature on that room
- A drone that mounts a LiDAR sensor for mapping purposes
- A science vessel that has many sensors installed
- An upstream oil well that is equipped with compound gas detection devices


[#thing-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of a Thing entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Definition*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `name`
| A property provides a label for Thing entity, commonly a descriptive name.
| String
| 1

| `definition`
| The URI linking the Thing to an external definition.
Dereferencing this URI SHOULD result in a representation of the definition of the Thing.
| URI
| 0..1

| `description`
| This is a short description of the corresponding Thing entity.
| String
| 0..1

| `properties`
| A JSON Object containing user-annotated properties.
| JSON_Object
| 0..1
|====


[#thing-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between a Thing entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*

| `Location`
| The Location entity locates the Thing.
Multiple Things MAY be located at the same Location.
A Thing MAY not have a Location.

A Thing SHOULD have only one physical location, but this location may be described in different ways, using different representations.
In such case, the Thing MAY have more than one Locations.
| `Location`
| 0..*

| `HistoricalLocations`
| A Thing has zero-to-many HistoricalLocations.
A HistoricalLocation has one-and-only-one Thing.
| `HistoricalLocation`
| 0..*

| `Datastreams`
| A Thing MAY have zero-to-many Datastreams.
| `Datastream`
| 0..*
|====

.Example of a Thing entity returned by a HTTP end point.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#Things/$entity",
  "@id": "Things(1)",
  "id": 1,
  "name": "Oven",
  "description": "This thing is an oven.",
  "properties": {
    "owner": "Ulrike Schmidt",
    "color": "Black"
  },
  "Locations@navigationLink": "Things(1)/Locations",
  "Datastreams@navigationLink": "Things(1)/Datastreams",
  "HistoricalLocations@navigationLink": "Things(1)/HistoricalLocations"
}
----





[[location]]
=== Location

[requirement]
.Class Location
====
[%metadata]
identifier:: {identifier}/req/datamodel/core/location

part:: Each Location entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<location-attributes>>.

part:: Each Location entity SHALL have the direct relation between a Location entity and other entity types listed in <<location-relations>>.
====


The Location entity geo-locates the Thing or the Things it associated with.
A Thing's Location entity is defined as the last known location of the Thing.

Section 7.1.4 of [<<OgcOMS>> and <<IsoOMS>>] provides a detailed explanation of observation location.
Examples of the use of Location are:

- An air quality sensing facility's Location can be the physical location where the facility is situated, but the (proximate) Feature that is characterized by the Observation could be the air envelope around the Sensor which is subsequently used to estimate the air quality of the district where the facility is situated.

- A drone that mounts a LiDAR Sensor may have its Location as the geo-referenced area over which the drone is scheduled to fly, whereas the Feature could be the individual objects mapped by the Sensor within that geo-referenced area



[#location-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of a Location entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Definition*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `name`
| A property provides a label for Location entity, commonly a descriptive name.
| String
| 1

| `definition`
| The URI linking the Location to an external definition.
Dereferencing this URI SHOULD result in a representation of the definition of the Location.
| URI
| 0..1

| `encodingType`
| The encoding type of the Location property.
See <<location-encodingType-value-codes>> for some suggested values.
| IANA-MediaType
| 1

| `location`
| The identifiable location of the Thing
| ANY
| 1

| `description`
| The description about the Location
| String
| 0..1

| `properties`
| A JSON Object containing user-annotated properties.
| JSON_Object
| 0..1
|====



[#location-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between a Location entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*

| `Things`
| The Things located at the source Location.
Multiple Things MAY locate at the same Location.
| `Thing`
| 0..*

| `HistoricalLocations`
| The HistoricalLocations of things that have been located at this Location.
| `HistoricalLocation`
| 0..*
|====


[#location-encodingType-value-codes,reftext='{table-caption} {counter:table-num}']
.Non-exhaustive list of IANA-MediaType used for identifying types for the encodingType of the Location and Feature entities
[width="100%",cols="5,15",options="header"]
|====
| Encoding Type
| IANA-MediaType

| `GeoJSON`
| `application/geo+json`

| `GeoPose`
| `application/geopose+json`
|====


.Example of a Location entity using a GeoJSON Feature.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#Locations/$entity",
  "@id": "Locations(1)",
  "id": 1,
  "name": "CCIT",
  "description": "Calgary Center for Innvative Technologies",
  "encodingType": "application/geo+json",
  "location": {
    "type": "Feature",
    "geometry":{
      "type": "Point",
      "coordinates": [-114.06,51.05]
    }
  },
  "Things@navigationLink": "Locations(1)/Things",
  "HistoricalLocations@navigationLink": "Locations(1)/HistoricalLocations",
}
----

.Example of a Location entity using a GeoJSON Geometry.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#Locations/$entity",
  "@id": "Locations(2)",
  "id": 2,
  "name": "IOSB",
  "description": "Fraunhofer-Institut für Optronik, Systemtechnik und Bildauswertung IOSB",
  "encodingType": "application/geo+json",
  "location": {
    "type": "Point",
    "coordinates": [8.426, 49.015]
  },
  "Things@navigationLink": "Locations(2)/Things",
  "HistoricalLocations@navigationLink": "Locations(2)/HistoricalLocations",
}
----

NOTE: When using a GeoJSON encoding for the location attribute, the value can either be a GeoJSON Feature or a GeoJSON Geometry.

.Example of a Location entity using WKT.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#Locations/$entity", 
  "@id": "Locations(3)",
  "id": 3,
  "name": "Hamburg Port",
  "description": "Location at Hamburg Harbor",
  "encodingType": "text/plain",
  "location": "POINT(9.9937 53.5511)",
  "Things@navigationLink": "Locations(3)/Things",
  "HistoricalLocations@navigationLink": "Locations(3)/HistoricalLocations"
}
----


.Example of a Location entity using JSON-FG.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#Locations/$entity",
  "@id": "Locations(4)", 
  "id": 4,
  "name": "Weather Station Alpha",
  "description": "Rooftop weather monitoring station",
  "encodingType": "application/vnd.ogc.fg+json",
  "location": {
    "type": "Feature",
    "place": {
      "type": "Point",
      "coordinates": [13.4050, 52.5200]
    },
    "geometry": {
      "type": "Point",
      "coordinates": [13.4050, 52.5200]
    },
    "properties": {
      "floor": 5,
      "building": "Tower A",
      "installation_date": "2023-01-15"
    }
  },
  "Things@navigationLink": "Locations(4)/Things",
  "HistoricalLocations@navigationLink": "Locations(4)/HistoricalLocations"
}
----


.Example of a Location entity using OGC GeoPose.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#Locations/$entity",
  "@id": "Locations(5)",
  "id": 5, 
  "name": "Drone Camera Position",
  "description": "Position and orientation of aerial survey drone",
  "encodingType": "application/geopose+json",
  "location": {
    "position": {
      "lat": 48.8584,
      "lon": 2.2945,
      "h": 300.5
    },
    "quaternion": {
      "x": 0.0,
      "y": 0.0, 
      "z": 0.7071,
      "w": 0.7071
    }
  },
  "Things@navigationLink": "Locations(5)/Things",
  "HistoricalLocations@navigationLink": "Locations(5)/HistoricalLocations"
}
----



[[historicallocation]]
=== HistoricalLocation

[requirement]
.Class HistoricalLocation
====
[%metadata]
identifier:: {identifier}/req/datamodel/core/historical-location

part:: Each HistoricalLocation entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<historical-location-attributes>>.

part:: Each HistoricalLocation entity SHALL have the direct relation between a HistoricalLocation entity and other entity types listed in <<historical-location-relations>>.

part:: When the Locations relation of a Thing changes, a new HistoricalLocation SHALL be created and added to the Thing automatically by the service.
The current Location(s) of the Thing SHALL only be added to this autogenerated HistoricalLocation automatically by the service, and SHALL not be created as HistoricalLocation directly by user.

part:: When a user directly adds new HistoricalLocation, and the time of this new HistoricalLocation is later than the latest HistoricalLocation for the Thing, then the Locations of the Thing are changed to the Locations of this new HistoricalLocation.
====



A Thing's HistoricalLocation entity set provides the times of the current (i.e., last known) and previous locations of the Thing.
It can be used to model the path observed by a moving Thing.
An example of the use of HistoricalLocation is:

- A drone that measures methane leaks over a large basin may want to record the trajectory through which it flies.
HistoricalLocation should then record the individual Locations of the drone over time.


The HistoricalLocation can also be created, updated and deleted.
One use case is to migrate historical observation data from an existing observation data management system to a SensorThings API system.
Another use case is to track the Location of a Thing, when a permanent network connection is not available.
If the Location of a Thing is changed at a later time, when a network connection is available again, then the auto-generated Time of the HistoricalLocation entity would not reflect the time when the Thing was actually at the set Location, but only the time at which the change was sent to the server.
To resolve this, the Location of a Thing can also be changed by adding a HistoricalLocation.
If the time of a manually created HistoricalLocation is later than the time of all existing HistoricalLocations, then the Location of the Thing is updated to the Location of this manually created HistoricalLocation.


[#historical-location-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of a HistoricalLocation entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Definition*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `time`
| The time when the Thing is known at the Location.
| TM_Instant
| 1
|====


[#historical-location-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between a HistoricalLocation entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*

| Locations
| The Locations for this HistoricalLocation.
One HistoricalLocation SHALL have at least one Location.
| `Location`
| 1..*

| Thing
| The Thing this HistoricalLocation positions in time.
A HistoricalLocation has exactly one Thing.
| `Thing`
| 1
|====


.Example of a HistoricalLocation entity returned by a HTTP end point.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#HistoricalLocations/$entity",
  "@id": "HistoricalLocations(1)",
  "id": 1,
  "time": "2020-03-20T16:35:23.383586Z",
  "Thing@navigationLink": "HistoricalLocations(1)/Thing",
  "Locations@navigationLink": "HistoricalLocations(1)/Locations"
}
----





[[datastream]]
=== Datastream

[requirement]
.Class Datastream
====
[%metadata]
identifier:: {identifier}/req/datamodel/core/datastream

part:: Each Datastream entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<datastream-attributes>>.

part:: Each Datastream entity SHALL have the direct relation between a Datastream entity and other entity types listed in <<datastream-relations>>.
====


A Datastream groups a collection of Observations into a time series measuring the same ObservedProperties by the same Sensor for the same Thing and the same FeatureOfInterest.
Examples of Datastreams could be:

- An air quality monitoring station may have multiple Datastreams, each recording a specific pollutant measured by a specific sensor.
- A sensor that measures multiple ObservedProperties can generate a single Datastream with a composite resultType.

A Datastream can both have a Proximate- and an UltimateFeatureOfInterest.
The UltimateFeatureOfInterest is the broadest domain feature that the Observations in the Datastream can be said to represent.
The ProximateFeatureOfInterest is a more precise specification of a part of the Ultimate Feature.
An individual Observation can also have a ProximateFeatureOfInterest, which would, in most cases, be a sample with a limited set of Observations taken on it.

For example, in water quality the Ultimate FeatureOfInterest could be a river, while the ProximateFeatureOfInterest is a section of the river, or a specific point in the river where measurements or samples are taken.
If samples are taken, these samples are the ProximateFeatureOfInterest linked directly to the Observations taken on them.


[#datastream-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of a Datastream entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Definition*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `name`
| A property provides a label for Datastream entity, commonly a descriptive name.
| String
| 1

| `definition`
| The URI linking the Datastream to an external definition.
Dereferencing this URI SHOULD result in a representation of the definition of the Datastream.
| URI
| 0..1

| `description`
| The description of the Datastream entity.
| String
| 0..1

| `resultType`
| The formal description of the structure of the `result` attribute of the Observations in this Datastream.
Contains the unit of measurement and the `@id` of the ObservedProperty.
| JSON_Object (SWE-Common AbstractDataComponent)
| 1

| `resultEncoding`
| The encoding of the `result` attribute of the Observations in this Datastream.
The default encoding, used when this attribute is null or empty, is `JSONEncoding` with the default settings.
| JSON_Object (SWE-Common AbstractEncoding)
| 0..1

| `observedArea`
| The spatial bounding box of the spatial extent of the Feature that belong to the Observations associated with this Datastream.
This is usually generated by the server.
| Geometry
| 0..1

| `phenomenonTime`
| The temporal interval of the phenomenon times of all observations belonging to this Datastream.
This is usually generated by the server.
| TM_Period
| 0..1

| `resultTime`
| The temporal interval of the result times of all observations belonging to this Datastream.
This is usually generated by the server.
| TM_Period
| 0..1

| `properties`
| A JSON Object containing user-annotated properties.
| JSON_Object
| 0..1
|====

TM_Period is by default encoded as a complex type with a start (mandatory) and end (mandatory) attributes of type TM_Instant.


[#datastream-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between a Datastream entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*

| `Thing`
| The Thing this Datastream holds Observations for.
| `Thing`
| 1

| `Sensor`
| The Sensor that made the Observations in this Datastream.
| `Sensor`
| 1

| `ObservedProperty`
| The ObservedProperty of the Observations in this Datastream.
The Observations in a Datastream may hold values for multiple ObservedProperties, but the ObservedProperties are the same for all Observations in the same Datastream.
The service must ensure the linked ObservedProperties match the definitions used in the `resultType`.
| `ObservedProperty`
| 1..*

| `Observations`
| The Observations for a Datastream.
| `Observation`
| 0..*

| `ProximateFeatureOfInterest`
| This relation links to a Feature that has the role ProximateFeatureOfInterest for all the Observations in a Datastream.
| `Feature`
| 0..1

| `UltimateFeatureOfInterest`
| This relation links to a Feature that has the role UltimateFeatureOfInterest for all the Observations in a Datastream.
| `Feature`
| 0..1
|====


The resultType defines the result types for specialized single and multi observations based on the JSON encoding of the SWE Common Data Model (<<ogc08-094>> and <<ogc17-011>>, or, once released: <<SweCommon>>).
The result of an Observation may be a single simple number or String, or it may contain a complex JSON structure holding multiple values for multiple ObservedProperties.
The exact definition for this result structure, and which unit of measurement and which ObservedProperty pertains to each value in the result structure is exactly described by this resultType Object.

The resultType contains references to the ObservedProperty or ObservedProperties of the Observations in the Datastream.
When a change is made to the resultType, the server MUST ensure the ObservedProperties linked to the Datastream match the references used in the the `definition` attribute(s) of the resultType, and create or remove relations as needed.
If the resultType contains references to non-existing ObservedProperties the request must be rejected with a Bad Request error.
The values of the definition attributes in the resultType must be valid entity-ids (`@id`) of ObservedProperties.
The structure of the resultType must not be changed once a Datastream has Observations, since the existing Observations would not fit the new structure.


EDITOR: Update reference to new SWE-Common: 24-014

In most cases each Observation holds a single numeric result value, measured by a single Sensor.
In this case the resultType is of the SWE-Common class `Quantity` (though a number could also be a `Count`) and thus must have the attributes `type`, `definition`, `label`, and `uom`.

- The `type` attribute defines the type of the result and has the value `Quantity`.
- The `definition` must be the same as the `definition` attribute in the single ObservedProperty linked to the Datastream.
- The `uom` attribute contains the unit of measurement, and is an object that must contain either a `code` attribute with the UCUM code of the unit, or a `href` attribute with a URI pointing to a unit definition.
It may also contain the `label` and `symbol` attributes that can be displayed in user interfaces.
- The `label` attribute is somewhat redundant in this case, but since it is mandatory it can be set to the same value as the ObservedProperty `name`.


.A Datastream example measuring a scalar Observation
[source,json]
----
{
  "name": "Oven temperature",
  "description": "This is a datastream measuring the air temperature in an oven.",
  "resultType": {
    "type": "Quantity",
    "label": "Temperature",
    "definition": "ObservedProperties(1)",
    "uom": { "code": "Cel", "label": "degree Celsius", "symbol": "°C" }
  }
}
----

.An Observation for the Datastream defined in the example above
[source,json]
----
{
  "result": 25.1,
  "phenomenonTime":  {
    "start": "2021-13-14T15:16:00Z"
  }
}
----


Another common type of result is a value from a key list.
An example would be an Observation of the current weather as `Fair` or `Overcast`, or the geological dating of a rock sample to be `Jurassic`.
In the latter case, the code space that defines the values could be the Sweet ontology.
In this example the resultType is a `Category` and thus must have the attributes `type`, `definition`, `label`, and `codeSpace`.

- The `type` attribute defines the type of the result and has the value `Category`.
- The `definition` must be the same as the `definition` attribute in the single ObservedProperty linked to the Datastream.
- The `codeSpace` attribute must be a reference that defines the valid values that can be used as results.
- The `label` attribute is somewhat redundant in this case, but since it is mandatory it can be set to the same value as the ObservedProperty `name`.


.A Datastream example for Observations with category values from a predefined code space
[source,json]
----
{
  "name": "Sample Dating",
  "description": "This is a datastream containing the geological datings of rock samples.",
  "resultType": {
    "type": "Category",
    "label": "Period",
    "definition": "ObservedProperties(2)",
    "codeSpace": "http://sweetontology.net/stateTimeGeologic/"
  }
}
----

.An Observation for a Datastream defined in the example above
[source,json]
----
{
  "result": "Jurassic",
  "phenomenonTime":  {
    "start": "2021-13-14T15:16:00Z"
  }
}
----


In some cases, a (composite) Sensor generates multiple values that should be kept together.
This can be achieved with a `DataRecord` resultType.
In the below example, a temperature and pressure value are stored as a pair, per Observation.
The resultType has the SWE-Common class `DataRecord`, which is a composite class that contains sub-entries.
The mandatory attributes of a DataRecord are `type` and `fields`:

- The `type` attribute defines the type of the result and has the value `DataRecord`.
- The `fields` attribute is an array of other SWE-Common components.
  In this example there are two `Quantity` entries.
  Each entry has the mandatory attributes for a `Quantity`.

Since there are two _distinct_ `definition` attributes in the resultType, this Datastream must be linked to two ObservedProperties that match the two definitions.

.A Datastream example measuring multiple observedProperties
[source,json]
----
{
  "name": "Temperature and Pressure",
  "description": "This is a datastream containing temperature and pressure measurement sets.",
  "resultType": {
    "type": "DataRecord",
    "fields": [
      {
        "name": "temp",
        "type": "Quantity",
        "label": "Air Temperature",
        "definition": "ObservedProperties(1)",
        "uom": { "code": "Cel", "label": "degree Celsius", "symbol": "°C"  }
      },
      {
        "name": "press",
        "type": "Quantity",
        "label": "Air Pressure",
        "definition": "ObservedProperties(3)",
        "uom": { "code": "mbar", "label": "Millibar", "symbol": "mBar"  }
      }
    ]
  }
}
----

.An Observation for a Datastream defined in the example above
[source,json]
----
{
  "result": {
    "temp": 15,
    "press": 1024
  },
  "phenomenonTime": {
    "start": "2021-13-14T15:16:00Z"
  }
}
----


The `resultEncoding` attribute, can be used to specify how the structure from the `resultType` attribute is encoded in the `result` attribute of the Observations.
If the `resultEncoding` is empty, or null, a JSONEncoding is used with the default configuration, as seen in the examples above.
The example below specifies a modified JSONEncoding, to mimic the result encoding of the MultiDatastream, as specified in version 1.1 of the SensorThings API.

.A Datastream example measuring multiple observedProperties using a custom encoding to mimic the old MultiDatastream format
[source,json]
----
{
  "name": "Temperature and Pressure",
  "description": "This is a datastream containing temperature and pressure measurement sets.",
  "resultType": {
    "type": "DataRecord",
    "fields": [
      {
        "name": "temp",
        "type": "Quantity",
        "label": "Air Temperature",
        "definition": "ObservedProperties(1)",
        "uom": { "code": "Cel", "label": "degree Celsius", "symbol": "°C"  }
      },
      {
        "name": "press",
        "type": "Quantity",
        "label": "Air Pressure",
        "definition": "ObservedProperties(3)",
        "uom": { "code": "mbar", "label": "Millibar", "symbol": "mBar"  }
      }
    ]
  },
  "resultEncoding": {
    "type": "JSONEncoding",
    "recordsAsArrays": true
  }
}
----

.An Observation for a Datastream defined in the example above
[source,json]
----
{
  "result": [15, 1024]
  },
  "phenomenonTime": {
    "start": "2021-13-14T15:16:00Z"
  }
}
----



[[sensor]]
=== Sensor

[requirement]
.Class Sensor
====
[%metadata]
identifier:: {identifier}/req/datamodel/core/sensor

part:: Each Sensor entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<sensor-attributes>>.

part:: Each Sensor entity SHALL have the direct relation between a Sensor entity and other entity types listed in <<sensor-relations>>.
====

A Sensor is an entity that observes a property or phenomenon with the goal of producing an estimate of the value of the property.
A Sensor may represent a piece of hardware, but a Sensor may also be a human or an algorithm implemented in sofware.

A Sensor entity in a SensorThings API deployment can represent either a specific sensor instance, or a more generic sensor type.
The distinction is generally quite clear from the Sensor metadata.
Does the entity have detailed metadata that is specific to a sensor instance, like a serial number and calibration data, or is it used for many Datastreams attached to many different Things.


[#sensor-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of a Sensor entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Definition*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `name`
| A property provides a label for Sensor entity, commonly a descriptive name.
| String
| 1

| `definition`
| The URI linking the Thing to an external definition.
Dereferencing this URI SHOULD result in a representation of the definition of the Thing.
| URI
| 0..1

| `description`
| The description of the Sensor entity.
| String
| 0..1

| `encodingType`
| The encoding type of the metadata property.
See <<sensor-encodingType-value-codes>> for some suggested values.
| IANA-MediaType
| 0..1

| `metadata`
| The detailed description of the Sensor or system.
The metadata type is defined by encodingType.
| String
| 0..1

| `properties`
| A JSON Object containing user-annotated properties as key-value pairs
| JSON_Object
| 0..1
|====


[#sensor-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between a Sensor entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*

| `Datastreams`
| The Datastreams that hold Observations produced by this Sensor.
| `Datastream`
| 0..*
|====


[#sensor-encodingType-value-codes,reftext='{table-caption} {counter:table-num}']
.Non-exhaustive list of code values used for identifying types for the encodingType of the Sensor entity
[width="100%",cols="5,15",options="header"]
|====
| Sensor Encoding Type
| IANA-MediaType

| `PDF`
| application/pdf

| `HTML`
| text/html
|====


The Sensor encodingType allows clients to know how to interpret the metadata value.
Note that the metadata property may contain either a URL to metadata content (e.g., an `https://`, `ftp://`, etc. link to a PDF, SensorML, or HTML document) or the metadata content itself (in the case of text/plain or other encodingTypes that can be represented as valid JSON).
It is up to clients to perform string parsing necessary to properly handle metadata content.


.Example of a Sensor entity returned by a HTTP end point.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#Sensors/$entity",
  "@id": "Sensors(1)",
  "id": 1,
  "name": "TMP36",
  "description": "TMP36 - Analog Temperature sensor",
  "encodingType": "application/pdf",
  "metadata": "http://example.org/TMP35_36_37.pdf",
  "Datastreams@navigationLink": "Sensors(1)/Datastreams"
}
----




[[observedproperty]]
=== ObservedProperty

[requirement]
.Class ObservedProperty
====
[%metadata]
identifier:: {identifier}/req/datamodel/core/observed-property

part:: Each ObservedProperty entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<observed-property-attributes>>.

part:: Each ObservedProperty entity SHALL have the direct relation between an ObservedProperty entity and other entity types listed in <<observed-property-relations>>.
====

An ObservedProperty is a property of a Feature that is being observed by a Sensor, such as temperature, humidity, population count or colour.
It should be uniquely identified by its `definition`, which should point to an external vocabulary by means of a URL, URI or DID.


[#observed-property-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of an ObservedProperty entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Definition*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `name`
| A property provides a label for ObservedProperty  entity, commonly a descriptive name.
| String
| 1

| `definition`
| The URI of the ObservedProperty.
Dereferencing this URI SHOULD result in a representation of the definition of the ObservedProperty.
The definition SHOULD be unique in a service.
| URI
| 1

| `description`
| A description about the ObservedProperty.
| String
| 0..1

| `properties`
| A JSON Object containing user-annotated properties as key-value pairs
| JSON_Object
| 0..1
|====


[#observed-property-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between an ObservedProperty entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*

| `Datastreams`
| Datastreams that hold Observations that observed this ObservedProperty.
| `Datastream`
| 0..*
|====


.Example of an ObservedProperty entity returned by a HTTP end point.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#ObservedProperties/$entity",
  "@id": "ObservedProperties(1)",
  "id": 1,
  "name": "DewPoint Temperature",
  "description": "The dewpoint temperature is the temperature to which the
                  air must be cooled, at constant pressure, for dew to form.
                  As the grass and other objects near the ground cool to
                  the dewpoint, some of the water vapor in the atmosphere
                  condenses into liquid water on the objects.",
  "definition": "http://dbpedia.org/page/Dew_point",
  "Datastreams@navigationLink": "ObservedProperties(1)/Datastreams"
}
----





[[observation]]
=== Observation

[requirement]
.Class Observation
====
[%metadata]
identifier:: {identifier}/req/datamodel/core/observation

part:: Each Observation entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<observation-attributes>>.

part:: Each Observation entity SHALL have the direct relation between an Observation entity and other entity types listed in <<observation-relations>>.
====


An Observation provides a value for an ObservedProperty of a Feature, as observed by a Sensor.
This value can be of any type, as described by the resultType of the Datastream that Observation is associated with.


[#observation-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of an Observation entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Definition*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `phenomenonTime`
| The time instant or period of when the Observation happens.

Note: Many resource-constrained sensing devices do not have a clock.
As a result, a client may omit phenomenonTime when POST new Observations, even though phenomenonTime is a mandatory property.
When a SensorThings service receives a POST Observations without phenomenonTime, the service SHALL assign the current server time to the value of the phenomenonTime
| TM_Object
| 1

| `result`
| The estimated value of an ObservedProperty from the Observation.
| ANY
| 1
| `resultTime`
| The time of the Observation's result was generated
| TM_Instant
| 0..1

| `validTime`
| The time period during which the result may be used
| TM_Period
| 0..1

| `properties`
| A JSON Object containing user-annotated properties as key-value pairs (usually showing the environmental conditions during measurement)
| JSON_Object
| 0..1
|====

TM_Object is by default encoded as a complex type with a start (mandatory) and end (optional) attributes of type TM_Instant.
This means it can either describe a time instant, when only the start is present, or a time interval with both stand and end are present.

TM_Period is by default encoded as a complex type with a start (mandatory) and end (mandatory) attributes of type TM_Instant.
This means it always describes a time interval with fixed starting and ending instants.



[#observation-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between an Observation entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*

| `Datastream`
| The Datastream this Observation exists in.
| `Datastream`
| 1

| `ProximateFeatureOfInterest`
| The Feature observed by the Observation.
| `Feature`
| 0..1
|====

An Observation can be directly linked to a Feature, through the relation `ProximateFeatureOfInterest`.
Features linked to an Observation in this way are generally samples, either real, physical ones, like water samples taken from a river, or transient ones, to fix the place that a moving Thing happended to be in, when it made a measurement.

In case the Feature is a domain object, like a river, a building, or a plot of land, the Feature is indirectly linked to the Observation through the `UltimateFeatureOfInterest` or `ProximateFeatureOfInterest` relations on the Datastream.
It is also possible for all relations to exist, in which case the `ProximateFeatureOfInterest` of the Observation is a sample of the `ProximateFeatureOfInterest` of the Datastream, which is, in turn, a part of the `UltimateFeatureOfInterest`.

A third case is possible, when the target of the observation is (a sub-part of) the Thing itself.
For instance, when the Observation is on the battery-level of a drone.
In this case neither the `ProximateFeatureOfInterest` on the Observation, nor the `ProximateFeatureOfInterest` or `UltimateFeatureOfInterest` relations on the Datastream need to be set.


.Example of an Observation entity returned by a HTTP end point.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#Observations/$entity",
  "@id": "Observations(1)",
  "id": 1,
  "phenomenonTime": {
    "start": "2017-11-12T13:00:00Z",
    "end": "2017-11-12T14:00:00Z"
  },
  "resultTime": "2017-11-12T14:00:00Z",
  "result": 12.5,
  "Datastream@navigationLink": "Observations(1)/Datastream",
  "ProximateFeatureOfInterest@navigationLink": "Observations(1)/ProximateFeatureOfInterest"
}
----




[[feature]]
=== Feature

[requirement]
.Class Feature
====
[%metadata]
identifier:: {identifier}/req/datamodel/core/feature

part:: Each Feature entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<feature-attributes>>.

part:: Each Feature entity SHALL have the direct relation between a Feature entity and other entity types listed in <<feature-relations>>.
====


An Observation assigns a value to a property of a subject by applying an ObservingProcedure.
The subject is the Feature that can take the role of ProximateFeatureOfInterest or UltimateFeatureOfInterest of the Observation [<<OgcOMS>> and <<IsoOMS>>].
In cases where estimating the value of a property of interest is not possible directly, a proxy feature MAY be used.
Such an application typically requires taking a sample of the UltimateFeatureOfInterest such that this sample, the ProximateFeatureOfInterest, represents an approximation of the domain feature.

Some examples of features are:

- The Ultimate Feature of a WiFi enabled thermostat, with a built-in temperature sensor, can be the room that the thermostat monitors.
The exact position of the themostat is captured in a Location entity of the Thing representing the thermostat.

- In the case of water quality monitoring, water samples are taken from a river at a specific sampling location.
The water sample, the sampling location and the river are all Features.
The river is the UltimateFeatureOfInterest attached to the Datastreams of the Observations taken on the sample.
The sampling location is the ProximateFeatureOfInterest attached to the Datastreams of the Observations taken on the sample.
Finally, the sample is the ProximateFeatureOfInterest directly attached to the various Observations.

- In the case of remote sensing, the Feature observed can be the individual geographical parcel or swath that is being sensed, while the Location entity captures the position of the device (drone, sattellite) that hosts the sensors.



[#feature-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of a Feature entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Definition*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `name`
| A property provides a label for Feature entity, commonly a descriptive name.
| String
| 1

| `definition`
| The URI linking the Feature to an external definition.
Dereferencing this URI SHOULD result in a representation of the definition of the Feature.
| URI
| 0..1

| `description`
| The description about the Feature
| String
| 0..1

| `encodingType`
| The encoding type of the feature property.
See <<location-encodingType-value-codes>> for some suggested values.
| IANA-MediaType
| 1

| `feature`
| The detailed description of the feature.
The data type is defined by encodingType.
| ANY
| 1

| `properties`
| A JSON Object containing user-annotated properties as key-value pairs
| JSON_Object
| 0..1
|====


[#feature-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between a Feature entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*                

| `Observations`
| All Observations that are made on this Feature
| `Observation`
| 0..*

| `DatastreamsProximate`
| All Datastreams for the Observations of which this Feature is a ProximateFeatureOfInterest.
| `Datastream`
| 0..*

| `DatastreamsUltimate`
| All Datastreams for the Observations of which this Feature is the UltimateFeatureOfInterest.
| `Datastream`
| 0..*
|====


.Example of a Feature entity using a GeoJSON Geometry.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#Features/$entity",
  "@id": "Features(1)",
  "id": 1,
  "name": "0113700020130227",
  "description": "Water Sample from LA NOYE À DOMMARTIN (80) taken on 2013-02-27 at 10:20:00",
  "encodingType": "application/geo+json",
  "feature": {
    "type": "Point",
    "coordinates": [
      2.38961955,
      49.800951554
    ]
  },
  "FeatureType@navigationLink": "Features(1)/FeatureType",
  "Datastreams@navigationLink": "Features(1)/Datastreams",
  "Observations@navigationLink": "Features(1)/Observations"
}
----

.Example of a Feature entity using WKT Geometry.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#Features/$entity", 
  "@id": "Features(2)",
  "id": 2,
  "name": "City Center Park",
  "description": "A public park located in the heart of the city",
  "encodingType": "application/vnd.ogc.wkt",
  "feature": "POLYGON((30 10, 40 40, 20 40, 10 20, 30 10))",
  "FeatureType@navigationLink": "Features(2)/FeatureType",
  "Datastreams@navigationLink": "Features(2)/Datastreams",
  "Observations@navigationLink": "Features(2)/Observations"
}
----






[[featuretype]]
=== FeatureType

[requirement]
.Class FeatureType
====
[%metadata]
identifier:: {identifier}/req/datamodel/core/feature-type

part:: Each FeatureType entity SHALL have the mandatory attributes and MAY have the optional attributes listed in <<feature-type-attributes>>.

part:: Each FeatureType entity SHALL have the direct relation between a FeatureType entity and other entity types listed in <<feature-type-relations>>.
====


The type or types of each Feature can be specified using the FeatureType class.
The `definition` attribute of the FeatureType should point to an external registry or code list, that defines the Type.


[#feature-type-attributes,reftext='{table-caption} {counter:table-num}']
.Attributes of a FeatureType entity
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Name*
| *Description*
| *Data Type*
| *Multiplicity*

| `id`
| A unique, read-only attribute that serves as an identifier for the entity.
| ANY
| 1

| `name`
| A property provides a label for Feature entity, commonly a descriptive name.
| String
| 1

| `definition`
| The URI the defines this FeatureType.
Dereferencing this URI SHOULD result in a representation of the definition of the FeatureType.
| URI
| 0..1

| `description`
| The description about the Feature
| String
| 0..1

| `properties`
| A JSON Object containing user-annotated properties as key-value pairs
| JSON_Object
| 0..1
|====


[#feature-type-relations,reftext='{table-caption} {counter:table-num}']
.Direct relation between a FeatureType entity and other entity types
[width="100%",cols="<3a,<20a,<3a,<",options="header"]
|====
| *Role*
| *Description*
| *Target Entity Type*
| *Multiplicity*                

| `Features`
| All Features of a FeatureType.
| `Feature`
| 0..*
|====


.Example of a FeatureType entity.
[source,json]
----
{
  "@context": "https://example.org/v2.0/$metadata#FeatureType/$entity",
  "@id": "FeatureType(1)",
  "id": 1,
  "name": "Water Sample",
  "description": "A Sample taken from a river, lake or sea",
  "definition": "https://example.org/water_sample",
  "Features@navigationLink": "FeatureType(1)/Features"
}
----



