=== Security Considerations
Writing security considerations for implementing STA 2.0 is challenging.
This is because the range of uses of a STA 2.0 API implementation cannot be always known.
The use cases for an implementation could vary from automated tools for analytical purposes that fetch data (observations) to produce statistics, reports, etc. to Web-Mapping applications running in a Web Browser that interact with a STA 2.0 service based on user interactions like pan, zoom in and zoom out.
In other words, the use spans from procedural to user driven interactions.
Then there are also simple sensor systems that publish data via MQTT as well as observation procedures that subscribe to updates of data.
All this must be taken into consideration when speaking of security requirements.

Given that STA 2.0 provides two different interfaces -- HTTP and MQTT -- and the different use cases, this section is separated into three parts: General considerations, considerations for an HTTP interface, and considerations for an MQTT interface.


==== General Considerations

Typical security considerations should address the following topics:

* authentication
* authorization
* integrity
* confidentiality
* availability
* data assurance


===== Authentication

The STA 2.0 Standard specifies a conformance class that allows limiting access to the HTTP and MQTT interface to identified actors only.
In particular, the HTTP status code 401 can be used to signal to the caller that authentication such as an API-key, is required. 

===== Authorization

The STA 2.0 Standard does not define how authorization can be applied.
Any implementation of STA 2.0 may implement authorization.
The STA 2.0 Standard defines the use of HTTP status code 403 to signal to the caller that execution of the request is forbidden.

===== Integrity and Confidentiality

The STA 2.0 Standard does not define how to achieve integrity and confidentiality of the stored data.
This means that without implementing authorization, any caller can overwrite existing information or view potentially sensitive data.

===== Availability 
Availability is a key aspect for any service based infrastructure.
To ensure availability, any implementation needs to understand the resource allocation for any type of request.
The STA 2.0 HTTP interface is based on ODATA with an extension to define options for geospatial data.
To ensure high availability, complex ODATA queries involving complex geospatial conditions may require a high load of resources like CPU and main memory.
Any implementation should carefully analyze the request query parameters (the ODATA options) before executing the request.
To prevent (perhaps accidental) requests including complex ODATA queries, certain types of requests should require an API-Key.

===== Data Assurance

An implementation of the STA 2.0 Standard may support the creation of data via the HTTP and MQTT interface.
A client implementation should parse the uploaded data for scripting content.
For example cross-site scripting attacks may get executed in any Web-Application that carelessly includes data fetched from a STA 2.0 HTTP or MQTT interface into an HTML page.
To arrange an effective execution of an attack, the attacker would first upload some JavaScript to include in the result of an observation (or description of another entity).
For example `"; alert("xss attack!");//` footnote:[https://stackoverflow.com/questions/30661497/xss-prevention-and-innerhtml].
If the Web-Application renders the data via `document.getElementById("content").innerHTML = <obervation.result>;` the attack gets executed.


===== Client Implementation

When the STA HTTP interface supports CORS, any STA 2.0 API endpoint can be accessed from Web-Applications (JavaScript implementations executing in a Web Browser).
A simple Web-Application that fetches observations from a STA API endpoint to display a time chart potentially generates a high load on the server(s) that host the STA 2.0 implementation.
Typical Web-Mapping libraries like OpenLayers and Leaflet split the canvas into tiles and make a request for each tile in parallel.
With fast zoom in and out and panning the area of interest changes and the STA 2.0 HTTP interface receives many requests basically for nothing, because fast zoom and pan means that the user is navigating to an area of interest.
If for each of the zoom and pan steps, the STA HTTP interface is hit, a high server load is produced for nothing.

Another aspect regarding client development is caching: A Web Browser supports caching of static data such as images.
However, the result from a STA service endpoint is a dynamically created JSON response.
This is typically not automatically cached in the Web Browser.
To avoid useless interactions with the STA service, a Web-Application should implement efficient caching.

A STA deployment should control, via the CORS configuration, which Web-Application to trust.


==== Considerations for the HTTP Interface

Among the typical security considerations that exist for HTTP interfaces, the STA 2.0 Standard -- as well as previous versions -- specify requirements for the use of ODATA query options.

===== Access Control aspects

An implementation of a STA HTTP interface is very complex in terms of arranging access control.
The complexity of the HTTP interface and the overwhelming flexibility of the ODATA options suggest that Access Control should be integrated into the STA implementation.
Even simple access control scenarios that allow or disallow access to an entity type may have side effects to other requests where such entity type is used internally.
For example, it may be possible that a particular entity type is not accessible directly via the HTTP interface but is allowed to participate in a `$filter` operation.
Also, the different "path to the same resources" challenge indicate that it would be not a good idea to implement access control using the proxy pattern.
For example, the combination of `$filter` and `$expand` is already difficult to be implemented into a proxy: `.../Observations?$expand=Datastream($fiter=id eq 1)` and `/Datastreams(1)/Observations` and `/FeaturesOfInterest/Observations?$expand=Datastream($fiter=id eq 1)` return similar data.

Implementing access control at the database level seems not only the best approach, it also seems to provide the best performance.


===== Confidentiality aspects

When not all data is public accessible, a specific type of access control needs to be included in the application.
Similar to the access control example, the granularity level suggests implementing the confidentiality control directly in the database and not in a proxy.


===== Synchronous aspects

The STA HTTP interface operates synchronously.
That means that a caller is waiting for the response on the established socket connection.
In the case where the implementation takes too long to start sending the first byte to the caller, the risk of a socket timeout arises.
To avoid the useless allocation of server resources, any connection timeout should be avoided.
To ensure that an implementation can be implemented "streaming ready", the STA 2.0 Standard only defines streaming ready response types.
For example, one typical format that is not streaming ready is a GeoPackage.
Any SQLite database must be fully created at server-side before the first byte of the response can be sent to the caller.

An implementation of the STA 2.0 Standard should consider streaming one record from the database to the HTTP or MQTT interface instead of loading the full database response into main memory to then send it to the caller.
This approach prevents high resource allocation and thereby improves service availability.



==== Considerations for the MQTT Interface

A STA 2.0 service implementation may expose an MQTT interface to the world.
Similar to the HTTP interface, the MQTT interface supports the creation of data via MQTT publish but also receives notifications of changes for registered MQTT topics.

The authentication mechanisms specified in the MQTT Standard can be used in an implementation of the MQTT interface of the STA 2.0 Standard.
This enables an implementation to restrict the subscription to "chatty" topics for some client identities.
Any openness of the MQTT interface may be used by adversaries to modify data, read sensitive data or even execute DoS attacks by submitting too many subscriptions for "chatty" topics like `Observations` or bulk publishing of bogus data.

The publish capability for the MQTT interface should be protected via an authentication mechanism to disallow anonymous users (or bots) to create bogus data or flush the service instance with bulk data.
Likewise, the subscription to chatty topics or to topics with complex ODATA options should only be allowed for authenticated callers.
