[[mqtt-interface-bindings]]
== MQTT Interface Bindings

=== Introduction

The MQTT Bindings specify how to access a STA endpoint using the MQTT 5.0 protocol (<<MQTT50>>).
This binding consists of three parts that can be implemented independently: <<mqtt_request_response>>, <<mqtt_publish_subscribe>> and <<mqtt_simple_create>>.


[requirements_class]
.MQTT Interface Bindings
====
[%metadata]
identifier:: {identifier}/req-class/binding/mqtt
obligation:: requirement
subject:: Interface Binding
requirement:: {identifier}/req/binding/mqtt/advertisement
requirement:: {identifier}/req/binding/mqtt/request_response
requirement:: {identifier}/req/binding/mqtt/pub_sub
requirement:: {identifier}/req/binding/mqtt/simple_create
====


[[mqtt_binding_advertisement]]
=== MQTT Binding Advertisement

To help a client find the MQTT endpoints of a STA service, the endpoints of the service are documented in the `+serverSettings+` object of the service documents of all request-response bindings, as described in <<read_service_document>>.
If the service supports any MQTT interface bindings, then the `+serverSettings+` object SHALL contain a attribute of type Object, with the name

`{identifier}/req/binding/mqtt`

This Object SHALL contain a attribute named `+endpoints+` of type Array. The JSON Array `+endpoints+` SHALL hold a list of URL Schemes that can be used to connect to the MQTT service


[requirement]
.Binding Advertisement
====
[%metadata]
identifier:: {identifier}/req/binding/mqtt/advertisement

If a service implements any MQTT bindings, then the MQTT endpoints of the service SHALL be advertised in the service documents of all implemented request-response bindings, as described in <<mqtt_binding_advertisement>>.
====



[[mqtt_request_response]]
=== Request / Response

MQTT 5.0 formalizes a request-response pattern over the MQTT protocol (<<MQTT50,section="4.10">>) that allows the use of the REST API over the MQTT protocol.
See <<mqtt5-req-res>> for a basic overview of the request-response pattern in MQTT 5.0.

MQTT 5.0 also defines User Properties (<<MQTT50,section="3.3.2.3.7">>) that can be used to pass application-defined key-value pairs with a published message.

[[mqtt5-req-res]]
[plantuml, title='MQTT 5 request-response pattern', reftext='{figure-caption} {counter:figure-num}']
....
@startuml
  skinparam responseMessageBelowArrow true
  participant Client as client
  participant "MQTT5 Broker" as broker
  participant RequestHandler as rh

  == Setup RequestHandler ==
  rh -> broker: CONNECT
  rh <-- broker: CONNACK

  rh -> broker: SUBSCRIBE v2.0/requests
  rh <-- broker: ok

  == Setup Client ==

  client -> broker: CONNECT\nrequestResponseInformation=true
  client <-- broker: CONNACK\nResponseInformation:responses/userXyz

  client -> broker: SUBSCRIBE responses/userXyz
  client <-- broker: ok

  ...

  == Request-Response ==
  client -> broker: PUBLISH v2.0/request\ncorrelationData=123xyz\nresponseTopic=responses/userXyz
  client <-- broker: ok

  broker -> rh: PUBLISH v2.0/request\ncorrelationData=123xyz\nresponseTopic=responses/userXyz
  broker <-- rh: ok

  rh -> rh: handle request

  rh -> broker: PUBLISH responses/userXyz\ncorrelationData=123xyz\nrequest response
  rh <-- broker: ok

  broker -> client: PUBLISH responses/userXyz\ncorrelationData=123xyz\nrequest response
  broker <-- client: ok
@enduml
....


Using the basic request-response pattern, and the User Properties of MQTT 5.0, the abstract STA API defined in <<abstract_api>> can be implemented over the MQTT protocol.

- Requests are sent to the topic `v2.0/$request`.
- The URL, including query parameters, for the request is passed in the User Attribute named `url`. The URL does not need to be URL-Encoded.
- The request type (<<request_types>>) is passed in the User Property named `type`.
- Request and response parameters (such as `prefer` and `location`)  are passed as User Properties.
- The status code of a response is passed in the User Attribute named `status`.
- The content type of a message is passed in the MQTT 5 property `Content Type` (<<MQTT50, section="3.3.2.3.9">>)
- Content is sent as the payload of the message.
- The request must contain a response topic that follows the `Response Information` passed by the broker.
- The request may contain correlation data to help the client associate the response to the request.
- All URLs pointing to the STA API start with the version of the STA API and contain no scheme, host or port and no preceding slash.

To minimize the size of the returned payload, by default the JSON format is used with `metadata=none` (<<format_json>>) and clients are advised to use the $select query parameter.


.Message requesting the service document
[source,text]
----
Topic: v2.0/$request
ResponseTopic: responses/userxyz
CorrelationData: 42
User Properties:
  url: v2.0
  type: read
Payload: <empty>
----

.Response message to the previous read request
[source,text]
----
Topic: responses/userxyz
CorrelationData: 42
ContentType: application/json;charset=UTF-8
User Properties:
  status: 200
Payload: <the service document>
----


.Message requesting the first thing, ordered by id
[source,text]
----
Topic: v2.0/$request
ResponseTopic: responses/userxyz
CorrelationData: 43
User Properties:
  url: v2.0/Things?$top=1&$orderby=id
  type: read
Payload: <empty>
----

.Response message to the previous read request
[source,text]
----
Topic: responses/userxyz
CorrelationData: 43
ContentType: application/json;charset=UTF-8
User Properties:
  status: 200
Payload:
{
  "value": [
    {
      "id": 1,
      "name": "Oven",
      "description": "This thing is an oven.",
      "properties": {
        "owner": "Ulrike Schmidt",
        "color": "Black"
      }
    }
  ],
  "@nextLink": "v2.0/Things?$top=1&$skip=1&$orderby=id"
}
----



.Message creating a new thing
[source,text]
----
Topic: v2.0/$request
ResponseTopic: responses/userxyz
ContentType: application/json
User Properties:
  url: v2.0/Things
  type: create
Payload:
{
  "id": 1,
  "name": "Oven",
  "description": "This thing is an oven.",
  "properties": {
    "owner": "Ulrike Schmidt",
    "color": "Black"
  }
}
----

.Response message to the previous create request
[source,text]
----
Topic: responses/userxyz
User Properties:
  status: 201
  location: v2.0/Things(1)
Payload: <empty>
----


[requirement]
.Request / Response
====
[%metadata]
identifier:: {identifier}/req/binding/mqtt/request_response
inherit:: {identifier}/req-class/api/abstract

If a service advertises this requirement in the service document then the service SHALL implement the abstract API as described in <<mqtt_request_response>>.
====



[[mqtt_publish_subscribe]]
=== Publish / Subscribe

==== General


MQTT subscriptions are allowed on EntitySets (<<pattern_entityset>>, <<pattern_entityset_related>>), individual entities (<<pattern_entity>>, <<pattern_entity_related>>), and individual entity attributes (<<pattern_entity_attribute>>, <<pattern_entity_attribute_raw>>).

To get all updates for an EntitySet or Entity, clients can subscribe to the topic that matches the plain URL pattern, without service root, and without a preceding slash (`/`).

When an entity or attribute is created, updated/replaced or deleted, that is relevant for the subscription, the service returns a complete JSON representation of the affected entity in the payload of the message.

The action that caused the notification is specified in the User Property named `type`, with a value of `create`, `update` or `delete`.
Replace actions are published with the type `update`.


.Topic to use for receiving all updates for the Observations of a specific Datastream, and a typical message notifying about the creation of a new Observation
[source,text]
----
v2.0/Datastreams(4)/Observations

User Properties:
  type: create
Payload:
{
  "id": 123,
  "result": 45,
  "phenonmenonTime": "2015-02-05T17:00:00Z"
}
----


Since OData URLs are recursive, MQTT wildcards (`#` and `+`) are not allowed in subscriptions in the STA topic tree.

Like HTTP URLs, MQTT topics in the OGC SensorThings API can be extended with query options.
Query options are separated from the topic with a question mark character (`?`) and separated using an ampersand (`&`).
Query options are listed below.


[requirement]
.MQTT Publish / Subscribe
====
[%metadata]
identifier:: {identifier}/req/binding/mqtt/pub_sub
requirement:: {identifier}/req/binding/mqtt/pub_sub/select
requirement:: {identifier}/req/binding/mqtt/pub_sub/expand
requirement:: {identifier}/req/binding/mqtt/pub_sub/filter

If a service advertises this requirement in the service document then the service SHALL implement the publish-subscribe API as described in <<mqtt_publish_subscribe>>.
====


[[mqtt_pubsub_select]]
==== $select

The '$select' query option (<<read_options_select>>) can be added to topics to reduce the amount of data that is sent.

.Topic to use for receiving all updates for the Observations of a specific Datastream, limited to only the phenomenonTime and result attributes
[source,text]
----
v2.0/Datastreams(4)/Observations?$select=phenomenonTime,result
----


[[req_mqtt_pubsub_select]]
[requirement]
.MQTT Publish / Subscribe Select
====
[%metadata]
identifier:: {identifier}/req/binding/mqtt/pub_sub/select

If a service advertises <<req_mqtt_pubsub_select>> in the service document then the service SHALL implement support for the `$select` option as described in <<mqtt_pubsub_select>>.
====


[[mqtt_pubsub_expand]]
==== $expand

The `$expand` query option (<<read_options_expand>>) can be added to topics to indicate that certain entities related to the created or updated entity should be sent.
For example, this can be useful when dealing with moving sensors, to receive new Observations together with their ProximateFeatureOfInterest.

.Topic to use for receiving all updates for the Observations of a specific Datastream
[source,text]
----
v2.0/Datastreams(4)/Observations?$expand=ProximateFeatureOfInterest
----


[[req_mqtt_pubsub_expand]]
[requirement]
.MQTT Publish / Subscribe Expand
====
[%metadata]
identifier:: {identifier}/req/binding/mqtt/pub_sub/expand

If a service advertises <<req_mqtt_pubsub_expand>> in the service document then the service SHALL implement support for the `$expand` option as described in <<mqtt_pubsub_expand>>.
====


[[mqtt_pubsub_filter]]
==== $filter

The $filter query option (<<read_options_filter>>) can be used to only receive notification of certain changes.


[[req_mqtt_pubsub_filter]]
[requirement]
.MQTT Publish / Subscribe Filter
====
[%metadata]
identifier:: {identifier}/req/binding/mqtt/pub_sub/filter

If a service advertises <<req_mqtt_pubsub_filter>> in the service document then the service SHALL implement support for the `$filter` option as described in <<mqtt_pubsub_filter>>.
====


[[mqtt_simple_create]]
=== Simple Create

Since simple clients, like sensors, may not be capable of handling the full MQTT request/response pattern, the simple-create pattern allows for a simpler way to create entities.
Entities can be created by sending a publish request to the topic of an 
EntitySet (<<pattern_entityset>>, <<pattern_entityset_related>>), without service root, and without a preceding slash (`/`), followed by `/create`.


.Publish message used to create an Observation in Datastream 4.
[source,text]
----
Topic: v2.0/Datastreams(4)/Observations/create
Payload:
{
  "result": 42,
  "phenomenonTime": {
    "start": "2017-11-12T13:00:00Z"
  }
}
----


More advanced clients are adviced to use the MQTT Request/Response pattern to create entities, since it allows the server to return a success or failure response on entity creation.


[[req_mqtt_simple_create]]
[requirement]
.MQTT Simple Create
====
[%metadata]
identifier:: {identifier}/req/binding/mqtt/simple_create

If a service advertises <<req_mqtt_simple_create>> in the service document then the service SHALL implement support simple entity creation as described in <<mqtt_simple_create>>.
====

